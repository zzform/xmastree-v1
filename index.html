<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>Lumière de Noël</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Lato:wght@300;400&display=swap" rel="stylesheet">
    
    <!-- MediaPipe Hands -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    
    <!-- Babel -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <script>
      tailwind.config = {
        theme: {
          extend: {
            colors: {
              'christmas-green': '#023020',
              'christmas-gold': '#C5A059',
              'christmas-red': '#8A0303',
              'christmas-silver': '#E5E5E5',
            },
            fontFamily: {
              serif: ['Cinzel', 'serif'],
              sans: ['Lato', 'sans-serif'],
            },
          },
        },
      }
    </script>
    
    <style>
      body { margin: 0; padding: 0; overflow: hidden; background-color: #010a05; touch-action: none; }
      ::-webkit-scrollbar { display: none; }
      #root { width: 100vw; height: 100vh; }
      
      /* Initial HTML Loader to show while Babel compiles */
      #loader {
        position: fixed;
        inset: 0;
        background-color: #010a05;
        z-index: 9999;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        color: #C5A059;
        font-family: 'Cinzel', serif;
        transition: opacity 0.5s ease-out;
      }
      .spinner {
        width: 50px;
        height: 50px;
        border: 3px solid rgba(197, 160, 89, 0.3);
        border-radius: 50%;
        border-top-color: #C5A059;
        animation: spin 1s ease-in-out infinite;
        margin-bottom: 20px;
      }
      @keyframes spin {
        to { transform: rotate(360deg); }
      }
    </style>
    
    <!-- Fixed Import Map: Removed conflicting React 19 entry -->
    <script type="importmap">
{
  "imports": {
    "react": "https://esm.sh/react@18.2.0",
    "react/": "https://esm.sh/react@18.2.0/",
    "react-dom": "https://esm.sh/react-dom@18.2.0",
    "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
    "three": "https://esm.sh/three@0.160.0",
    "three/": "https://esm.sh/three@0.160.0/",
    "@react-three/fiber": "https://esm.sh/@react-three/fiber@8.15.16?external=react,react-dom,three",
    "@react-three/drei": "https://esm.sh/@react-three/drei@9.99.0?external=react,react-dom,three,@react-three/fiber",
    "@react-three/postprocessing": "https://esm.sh/@react-three/postprocessing@2.16.0?external=react,react-dom,three,@react-three/fiber",
    "lucide-react": "https://esm.sh/lucide-react@0.292.0?external=react",
    "react-dom/": "https://esm.sh/react-dom@^19.2.3/"
  }
}
</script>
  </head>
  <body>
    <!-- HTML Loader Visible Immediately -->
    <div id="loader">
      <div class="spinner"></div>
      <div class="text-xl tracking-widest">LOADING...</div>
    </div>

    <div id="root"></div>
    
    <!-- Application Logic -->
    <script type="text/babel" data-type="module" data-presets="react">
      import React, { useState, useEffect, useRef, useMemo, useCallback, Suspense } from 'react';
      import ReactDOM from 'react-dom/client';
      import * as THREE from 'three';
      import { Canvas, useFrame, useThree } from '@react-three/fiber';
      import { OrbitControls, Environment, Stars, Sparkles, Image, Loader } from '@react-three/drei';
      import { EffectComposer, Bloom, Vignette } from '@react-three/postprocessing';
      import { Upload, Camera, MousePointer2 } from 'lucide-react';

      /**
       * Constants
       */
      const AppMode = { TREE: 'TREE', EXPLODED: 'EXPLODED', FOCUS: 'FOCUS' };
      const GestureType = { IDLE: 'IDLE', FIST: 'FIST', OPEN_HAND: 'OPEN_HAND', PINCH: 'PINCH' };
      const COLORS = { EMERALD: '#023020', GOLD: '#C5A059', RED: '#8A0303', SILVER: '#E5E5E5' };
      const PARTICLE_COUNT = 300; // Reduced for Safari stability

      // Remove the HTML loader once React starts executing
      const loaderEl = document.getElementById('loader');
      if (loaderEl) {
        // We keep it visible until the Canvas mounts, but we can fade it out logic inside App
      }

      /**
       * Math Helpers
       */
      const generateTreePosition = (index, total, height = 15, radius = 6) => {
        const y = (index / total) * height - (height / 2);
        const normY = (y + height / 2) / height;
        const currentRadius = radius * (1 - normY);
        const angle = index * 137.5 * (Math.PI / 180);
        return [Math.cos(angle) * currentRadius, y, Math.sin(angle) * currentRadius];
      };

      const generateExplodedPosition = (radius = 15) => {
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(Math.random() * 2 - 1);
        const r = Math.cbrt(Math.random()) * radius;
        return [r * Math.sin(phi) * Math.cos(theta), r * Math.sin(phi) * Math.sin(theta), r * Math.cos(phi)];
      };

      /**
       * Gesture Service
       */
      const distance = (p1, p2) => Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
      const detectGesture = (landmarks) => {
        if (!landmarks || landmarks.length === 0) return GestureType.IDLE;
        const [wrist, , , , thumbTip, indexMCP, , , indexTip, middleMCP, , , middleTip, ringMCP, , , ringTip, pinkyMCP, , , pinkyTip] = landmarks;
        
        const isIndexOpen = distance(indexTip, wrist) > distance(indexMCP, wrist) * 1.2;
        const isMiddleOpen = distance(middleTip, wrist) > distance(middleMCP, wrist) * 1.2;
        const isRingOpen = distance(ringTip, wrist) > distance(ringMCP, wrist) * 1.2;
        const isPinkyOpen = distance(pinkyTip, wrist) > distance(pinkyMCP, wrist) * 1.2;
        const pinchDist = distance(thumbTip, indexTip);

        if (pinchDist < 0.05) return GestureType.PINCH;
        if (!isIndexOpen && !isMiddleOpen && !isRingOpen && !isPinkyOpen) return GestureType.FIST;
        if (isIndexOpen && isMiddleOpen && isRingOpen && isPinkyOpen) return GestureType.OPEN_HAND;
        return GestureType.IDLE;
      };

      /**
       * Components
       */
      const MediaPipeController = ({ onGestureUpdate, permissionGranted }) => {
        const videoRef = useRef(null);
        const handsRef = useRef(null);

        useEffect(() => {
          if (!permissionGranted || !videoRef.current || !window.Hands) return;
          
          const hands = new window.Hands({
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`,
          });

          hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5,
          });

          hands.onResults((results) => {
            if (results.multiHandLandmarks?.[0]) {
              const lm = results.multiHandLandmarks[0];
              onGestureUpdate({ type: detectGesture(lm), position: { x: lm[0].x, y: lm[0].y } });
            } else {
              onGestureUpdate({ type: GestureType.IDLE, position: { x: 0.5, y: 0.5 } });
            }
          });
          handsRef.current = hands;

          const startCamera = async () => {
             try {
               const stream = await navigator.mediaDevices.getUserMedia({ video: { width: 320, height: 240, facingMode: 'user' } });
               if (videoRef.current) {
                 videoRef.current.srcObject = stream;
                 await videoRef.current.play();
                 const send = async () => {
                   if (videoRef.current && handsRef.current) {
                     await handsRef.current.send({ image: videoRef.current });
                     requestAnimationFrame(send);
                   }
                 };
                 send();
               }
             } catch (e) { console.error(e); }
          };
          startCamera();

          return () => { hands.close(); };
        }, [permissionGranted]);

        return (
          <div className="fixed bottom-4 right-4 z-50 w-24 h-16 border border-christmas-gold rounded overflow-hidden bg-black opacity-50 hover:opacity-100 transition-opacity">
            <video ref={videoRef} className="w-full h-full object-cover -scale-x-100" playsInline muted />
          </div>
        );
      };

      const Ornaments = ({ mode }) => {
        const meshRef = useRef(null);
        const dummy = useMemo(() => new THREE.Object3D(), []);
        const color = useMemo(() => new THREE.Color(), []);
        
        const particles = useMemo(() => {
          const colors = [COLORS.GOLD, COLORS.RED, COLORS.SILVER, COLORS.EMERALD];
          return Array.from({ length: PARTICLE_COUNT }).map((_, i) => ({
            id: i,
            treePos: generateTreePosition(i, PARTICLE_COUNT),
            explodePos: generateExplodedPosition(12),
            color: colors[Math.floor(Math.random() * colors.length)],
            scale: Math.random() * 0.4 + 0.1
          }));
        }, []);

        // Use useEffect instead of useLayoutEffect for Safari stability
        useEffect(() => {
          if (meshRef.current) {
            particles.forEach((p, i) => {
              dummy.position.set(...p.treePos);
              dummy.scale.setScalar(p.scale);
              dummy.updateMatrix();
              meshRef.current.setMatrixAt(i, dummy.matrix);
              meshRef.current.setColorAt(i, color.set(p.color));
            });
            meshRef.current.instanceMatrix.needsUpdate = true;
          }
        }, [particles]);

        useFrame((state, delta) => {
          if (!meshRef.current) return;
          const step = 4 * delta;
          const time = state.clock.getElapsedTime();
          
          particles.forEach((p, i) => {
            let [tx, ty, tz] = p.treePos;
            if (mode === AppMode.EXPLODED || mode === AppMode.FOCUS) {
              const noise = Math.sin(time * 0.5 + p.id) * 0.5;
              tx = p.explodePos[0] + noise;
              ty = p.explodePos[1] + Math.cos(time * 0.3 + p.id) * 0.5;
              tz = p.explodePos[2];
            }
            
            // Extract current position from matrix to lerp
            meshRef.current.getMatrixAt(i, dummy.matrix);
            dummy.matrix.decompose(dummy.position, dummy.quaternion, dummy.scale);
            
            dummy.position.lerp(new THREE.Vector3(tx, ty, tz), step);
            dummy.rotation.x += delta * 0.5;
            dummy.rotation.y += delta * 0.5;
            dummy.updateMatrix();
            meshRef.current.setMatrixAt(i, dummy.matrix);
          });
          meshRef.current.instanceMatrix.needsUpdate = true;
        });

        return (
          <instancedMesh ref={meshRef} args={[undefined, undefined, PARTICLE_COUNT]} frustumCulled={false}>
            <icosahedronGeometry args={[1, 0]} />
            <meshStandardMaterial roughness={0.2} metalness={0.9} />
          </instancedMesh>
        );
      };

      // App Component
      const App = () => {
        const [mode, setMode] = useState(AppMode.TREE);
        const [gesture, setGesture] = useState({ type: GestureType.IDLE, position: { x: 0.5, y: 0.5 } });
        const [permissionGranted, setPermissionGranted] = useState(false);
        const [showIntro, setShowIntro] = useState(true);
        const [photos, setPhotos] = useState([
          'https://picsum.photos/id/1011/400/400',
          'https://picsum.photos/id/1015/400/400',
          'https://picsum.photos/id/1016/400/400',
        ]);
        
        // Remove HTML loader when React App mounts
        useEffect(() => {
          const l = document.getElementById('loader');
          if(l) l.style.display = 'none';
        }, []);

        const handleStart = async () => {
            try {
                await navigator.mediaDevices.getUserMedia({ video: true });
                setPermissionGranted(true);
                setShowIntro(false);
            } catch { alert('Permission denied'); }
        };

        return (
          <div className="relative w-full h-full font-sans text-christmas-silver">
             <Canvas shadows camera={{ position: [0, 0, 18], fov: 45 }} gl={{ antialias: false, powerPreference: "high-performance" }}>
                <color attach="background" args={['#010a05']} />
                
                {/* Wrap Heavy Assets in Suspense to prevent blocking */}
                <Suspense fallback={null}>
                   <Environment preset="city" />
                   <group position={[0, -2, 0]}>
                     <Ornaments mode={mode} />
                     <Sparkles count={150} scale={10} size={4} speed={0.4} opacity={0.5} color="#C5A059" />
                   </group>
                </Suspense>

                <ambientLight intensity={0.5} />
                <pointLight position={[10, 10, 10]} intensity={1} color="#C5A059" />
                
                <EffectComposer disableNormalPass>
                  <Bloom luminanceThreshold={0.5} intensity={1.5} radius={0.4} />
                  <Vignette eskil={false} offset={0.1} darkness={1.1} />
                </EffectComposer>
                
                <OrbitControls 
                   enableZoom={true} 
                   autoRotate={mode === AppMode.TREE} 
                   autoRotateSpeed={0.5} 
                   enablePan={false}
                />
             </Canvas>

             {/* UI Overlay */}
             <div className="absolute top-0 left-0 w-full p-6 pointer-events-none z-10">
                <h1 className="text-3xl font-serif text-christmas-gold drop-shadow-lg">LUMIÈRE DE NOËL</h1>
             </div>

             {/* Mode Controls */}
             {!permissionGranted && !showIntro && (
               <div className="absolute bottom-10 left-1/2 -translate-x-1/2 z-20 flex gap-4">
                  <button onClick={() => setMode(AppMode.TREE)} className="px-6 py-2 bg-christmas-gold text-black rounded font-serif">TREE</button>
                  <button onClick={() => setMode(AppMode.EXPLODED)} className="px-6 py-2 border border-christmas-gold text-christmas-gold rounded font-serif bg-black/50">EXPLODE</button>
               </div>
             )}

             {/* Intro */}
             {showIntro && (
                <div className="absolute inset-0 z-50 flex items-center justify-center bg-black/90 backdrop-blur">
                  <div className="text-center p-8 border border-christmas-gold/30 rounded bg-christmas-green/20">
                     <h2 className="text-4xl font-serif text-christmas-gold mb-6">Welcome</h2>
                     <button onClick={handleStart} className="bg-christmas-gold text-black px-8 py-3 rounded font-bold tracking-widest flex items-center gap-2 mx-auto">
                        <Camera size={20} /> ENABLE CAMERA
                     </button>
                     <button onClick={() => setShowIntro(false)} className="mt-4 text-xs text-gray-400 uppercase tracking-widest">Skip Camera</button>
                  </div>
                </div>
             )}

             {permissionGranted && (
               <MediaPipeController 
                  permissionGranted={permissionGranted} 
                  onGestureUpdate={(g) => {
                     if(g.type === GestureType.FIST) setMode(AppMode.TREE);
                     if(g.type === GestureType.OPEN_HAND) setMode(AppMode.EXPLODED);
                  }} 
               />
             )}
          </div>
        );
      };

      const root = ReactDOM.createRoot(document.getElementById('root'));
      root.render(<App />);
    </script>
  </body>
</html>