<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>Lumière de Noël</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Lato:wght@300;400&display=swap" rel="stylesheet">
    
    <!-- MediaPipe Hands -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    
    <!-- Babel for inline compilation -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <script>
      tailwind.config = {
        theme: {
          extend: {
            colors: {
              'christmas-green': '#023020',
              'christmas-gold': '#C5A059',
              'christmas-red': '#8A0303',
              'christmas-silver': '#E5E5E5',
            },
            fontFamily: {
              serif: ['Cinzel', 'serif'],
              sans: ['Lato', 'sans-serif'],
            },
          },
        },
      }
    </script>
    
    <style>
      body { margin: 0; padding: 0; overflow: hidden; background-color: #010a05; touch-action: none; }
      ::-webkit-scrollbar { display: none; }
      #root { width: 100vw; height: 100vh; }
      
      #loader {
        position: fixed;
        inset: 0;
        background-color: #010a05;
        z-index: 9999;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        color: #C5A059;
        font-family: 'Cinzel', serif;
        transition: opacity 0.5s ease-out;
      }
      .spinner {
        width: 50px;
        height: 50px;
        border: 3px solid rgba(197, 160, 89, 0.3);
        border-radius: 50%;
        border-top-color: #C5A059;
        animation: spin 1s ease-in-out infinite;
        margin-bottom: 20px;
      }
      .error-msg {
        color: #ef4444;
        margin-top: 1rem;
        font-family: monospace;
        font-size: 0.8rem;
        max-width: 90%;
        text-align: center;
      }
      @keyframes spin {
        to { transform: rotate(360deg); }
      }
    </style>
    
    <!-- STRICT IMPORT MAP: React 18.2.0 ONLY -->
    <script type="importmap">
{
  "imports": {
    "react": "https://esm.sh/react@18.2.0",
    "react/": "https://esm.sh/react@18.2.0/",
    "react-dom": "https://esm.sh/react-dom@18.2.0",
    "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
    "three": "https://esm.sh/three@0.160.0",
    "three/": "https://esm.sh/three@0.160.0/",
    "@react-three/fiber": "https://esm.sh/@react-three/fiber@8.15.16?external=react,react-dom,three",
    "@react-three/drei": "https://esm.sh/@react-three/drei@9.99.0?external=react,react-dom,three,@react-three/fiber",
    "@react-three/postprocessing": "https://esm.sh/@react-three/postprocessing@2.16.0?external=react,react-dom,three,@react-three/fiber",
    "react-dom/": "https://esm.sh/react-dom@^19.2.3/"
  }
}
</script>
    
    <script>
      // Global error handler for Safari debugging
      window.onerror = function(msg, url, line, col, error) {
        var loader = document.getElementById('loader');
        if (loader) {
          loader.innerHTML = '<div class="spinner" style="border-top-color:red"></div><div class="text-xl">ERROR</div><div class="error-msg">' + msg + '</div>';
        }
      };
    </script>
  </head>
  <body>
    <div id="loader">
      <div class="spinner"></div>
      <div class="text-xl tracking-widest">LOADING...</div>
    </div>

    <div id="root"></div>

    <!-- MAIN APPLICATION SCRIPT -->
    <!-- Consolidating all code here to avoid CORS issues with file:// protocol -->
    <script type="text/babel" data-type="module" data-presets="react, typescript">
      import React, { useState, useEffect, useCallback, useMemo, useRef, useLayoutEffect, Suspense } from 'react';
      import ReactDOM from 'react-dom/client';
      import * as THREE from 'three';
      import { Canvas, useFrame, useThree } from '@react-three/fiber';
      import { OrbitControls, Environment, Sparkles, Image, Stars, useCursor } from '@react-three/drei';
      import { EffectComposer, Bloom, Vignette } from '@react-three/postprocessing';

      // --- CONSTANTS & TYPES ---
      const AppMode = {
        TREE: 'TREE',
        EXPLODED: 'EXPLODED',
        FOCUS: 'FOCUS',
      };

      const GestureType = {
        IDLE: 'IDLE',
        FIST: 'FIST',
        OPEN_HAND: 'OPEN_HAND',
        PINCH: 'PINCH',
        POINT: 'POINT',
      };

      const COLORS = {
        EMERALD: '#023020',
        GOLD: '#C5A059',
        RED: '#8A0303',
        SILVER: '#E5E5E5',
        WHITE: '#FFFFFF',
      };

      const PARTICLE_COUNT = 400;

      // Math Helpers
      const generateTreePosition = (index, total, height = 15, radius = 6) => {
        const y = (index / total) * height - (height / 2);
        const normY = (y + height / 2) / height;
        const currentRadius = radius * (1 - normY);
        const angle = index * 137.5 * (Math.PI / 180);
        const x = Math.cos(angle) * currentRadius;
        const z = Math.sin(angle) * currentRadius;
        return [x, y, z];
      };

      const generateExplodedPosition = (radius = 15) => {
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(Math.random() * 2 - 1);
        const r = Math.cbrt(Math.random()) * radius;
        return [
          r * Math.sin(phi) * Math.cos(theta),
          r * Math.sin(phi) * Math.sin(theta),
          r * Math.cos(phi)
        ];
      };

      // --- SERVICES ---
      // Finger indices in MediaPipe Hands
      const INDICES = {
        WRIST: 0,
        THUMB_TIP: 4,
        INDEX_TIP: 8,
        INDEX_MCP: 5,
        MIDDLE_TIP: 12,
        MIDDLE_MCP: 9,
        RING_TIP: 16,
        RING_MCP: 13,
        PINKY_TIP: 20,
        PINKY_MCP: 17
      };

      const distance = (p1, p2) => {
        return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
      };

      const detectGesture = (landmarks) => {
        if (!landmarks || landmarks.length === 0) return GestureType.IDLE;

        const wrist = landmarks[INDICES.WRIST];
        const thumbTip = landmarks[INDICES.THUMB_TIP];
        const indexTip = landmarks[INDICES.INDEX_TIP];
        
        // Check extension
        const isIndexOpen = distance(indexTip, wrist) > distance(landmarks[INDICES.INDEX_MCP], wrist) * 1.2;
        const isMiddleOpen = distance(landmarks[INDICES.MIDDLE_TIP], wrist) > distance(landmarks[INDICES.MIDDLE_MCP], wrist) * 1.2;
        const isRingOpen = distance(landmarks[INDICES.RING_TIP], wrist) > distance(landmarks[INDICES.RING_MCP], wrist) * 1.2;
        const isPinkyOpen = distance(landmarks[INDICES.PINKY_TIP], wrist) > distance(landmarks[INDICES.PINKY_MCP], wrist) * 1.2;

        const pinchDist = distance(thumbTip, indexTip);
        if (pinchDist < 0.05) return GestureType.PINCH;
        if (!isIndexOpen && !isMiddleOpen && !isRingOpen && !isPinkyOpen) return GestureType.FIST;
        if (isIndexOpen && isMiddleOpen && isRingOpen && isPinkyOpen) return GestureType.OPEN_HAND;

        return GestureType.IDLE;
      };

      // --- COMPONENTS ---

      const MediaPipeController = ({ onGestureUpdate, permissionGranted }) => {
        const videoRef = useRef(null);
        const [cameraActive, setCameraActive] = useState(false);
        const handsRef = useRef(null);
        const requestRef = useRef(0);

        useEffect(() => {
          if (!permissionGranted || !videoRef.current) return;
          const mpHands = window.Hands;
          if (!mpHands) return;

          const hands = new mpHands({
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`,
          });

          hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5,
          });

          hands.onResults((results) => {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
              const landmarks = results.multiHandLandmarks[0];
              const gestureType = detectGesture(landmarks);
              onGestureUpdate({
                type: gestureType,
                position: { x: landmarks[0].x, y: landmarks[0].y },
              });
            } else {
              onGestureUpdate({ type: GestureType.IDLE, position: { x: 0.5, y: 0.5 } });
            }
          });

          handsRef.current = hands;

          const startCamera = async () => {
            try {
              const stream = await navigator.mediaDevices.getUserMedia({
                video: { width: 640, height: 480, facingMode: 'user' }
              });
              if (videoRef.current) {
                videoRef.current.srcObject = stream;
                await videoRef.current.play();
                setCameraActive(true);
                
                const processFrame = async () => {
                  if (!videoRef.current || !handsRef.current) return;
                  if (videoRef.current.readyState >= 2) { 
                    await handsRef.current.send({ image: videoRef.current });
                  }
                  requestRef.current = requestAnimationFrame(processFrame);
                };
                requestRef.current = requestAnimationFrame(processFrame);
              }
            } catch (err) { console.error(err); }
          };
          startCamera();

          return () => {
            cancelAnimationFrame(requestRef.current);
            if(handsRef.current) handsRef.current.close();
            if(videoRef.current && videoRef.current.srcObject) {
              videoRef.current.srcObject.getTracks().forEach(t => t.stop());
            }
          };
        }, [permissionGranted]);

        return (
          <div className="fixed bottom-4 right-4 z-50 w-32 h-24 border-2 border-christmas-gold rounded-lg overflow-hidden bg-black shadow-[0_0_15px_rgba(197,160,89,0.3)]">
            <video ref={videoRef} className="w-full h-full object-cover transform -scale-x-100" playsInline muted />
            {!cameraActive && permissionGranted && <div className="absolute inset-0 flex items-center justify-center text-xs text-christmas-gold bg-black/80">Loading...</div>}
          </div>
        );
      };

      const Ornaments = ({ mode }) => {
        const meshRef = useRef(null);
        const tempObject = useMemo(() => new THREE.Object3D(), []);
        const tempColor = useMemo(() => new THREE.Color(), []);

        const particles = useMemo(() => {
          const data = [];
          const colors = [COLORS.GOLD, COLORS.RED, COLORS.SILVER, COLORS.EMERALD];
          for (let i = 0; i < PARTICLE_COUNT; i++) {
            data.push({
              id: i,
              position: generateTreePosition(i, PARTICLE_COUNT),
              treePosition: generateTreePosition(i, PARTICLE_COUNT),
              explodedPosition: generateExplodedPosition(12),
              scale: Math.random() * 0.4 + 0.1,
              color: colors[Math.floor(Math.random() * colors.length)],
            });
          }
          return data;
        }, []);

        useLayoutEffect(() => {
          if (meshRef.current) {
            particles.forEach((p, i) => {
              tempObject.position.set(...p.treePosition);
              tempObject.scale.setScalar(p.scale);
              tempObject.updateMatrix();
              meshRef.current.setMatrixAt(i, tempObject.matrix);
              meshRef.current.setColorAt(i, tempColor.set(p.color));
            });
            meshRef.current.instanceMatrix.needsUpdate = true;
          }
        }, []);

        useFrame((state, delta) => {
          if (!meshRef.current) return;
          const step = 4 * delta;
          const time = state.clock.getElapsedTime();

          particles.forEach((p, i) => {
            let target = p.treePosition;
            if (mode === AppMode.EXPLODED || mode === AppMode.FOCUS) {
              const noiseX = Math.sin(time * 0.5 + p.id) * 0.5;
              const noiseY = Math.cos(time * 0.3 + p.id) * 0.5;
              target = [p.explodedPosition[0] + noiseX, p.explodedPosition[1] + noiseY, p.explodedPosition[2]];
            }
            
            p.position[0] = THREE.MathUtils.lerp(p.position[0], target[0], step);
            p.position[1] = THREE.MathUtils.lerp(p.position[1], target[1], step);
            p.position[2] = THREE.MathUtils.lerp(p.position[2], target[2], step);
            
            tempObject.position.set(...p.position);
            tempObject.rotation.x += delta * 0.5;
            tempObject.rotation.y += delta * 0.5;
            tempObject.scale.setScalar(p.scale);
            tempObject.updateMatrix();
            meshRef.current.setMatrixAt(i, tempObject.matrix);
          });
          meshRef.current.instanceMatrix.needsUpdate = true;
        });

        return (
          <instancedMesh ref={meshRef} args={[undefined, undefined, PARTICLE_COUNT]} castShadow receiveShadow>
            <icosahedronGeometry args={[1, 1]} />
            <meshStandardMaterial roughness={0.2} metalness={0.9} envMapIntensity={1.5} />
          </instancedMesh>
        );
      };

      const PhotoCloud = ({ photos, mode, activePhotoIndex }) => {
        const groupRef = useRef(null);
        
        const photoPositions = useMemo(() => {
          return photos.map((_, i) => ({
            tree: generateTreePosition(i, photos.length, 12, 7),
            exploded: generateExplodedPosition(10),
            rotation: [0, Math.random() * Math.PI, 0],
          }));
        }, [photos]);

        useFrame((state, delta) => {
          if (!groupRef.current) return;
          const step = 3 * delta;
          groupRef.current.children.forEach((child, i) => {
            const pos = photoPositions[i];
            let targetPos = new THREE.Vector3(...pos.tree);
            let targetScale = 1.5;
            let targetRot = new THREE.Euler(...pos.rotation);

            if (mode === AppMode.EXPLODED) {
              targetPos.set(...pos.exploded);
              targetRot.set(0,0,0);
            } else if (mode === AppMode.FOCUS) {
              if (activePhotoIndex === i) {
                targetPos.set(0, 0, 3);
                targetScale = 4;
                targetRot.set(0,0,0);
              } else {
                targetPos.set(...pos.exploded).multiplyScalar(2);
              }
            }

            child.position.lerp(targetPos, step);
            child.scale.lerp(new THREE.Vector3(targetScale, targetScale, 1), step);
            child.rotation.x = THREE.MathUtils.lerp(child.rotation.x, targetRot.x, step);
            child.rotation.y = THREE.MathUtils.lerp(child.rotation.y, targetRot.y, step);
            child.rotation.z = THREE.MathUtils.lerp(child.rotation.z, targetRot.z, step);

            if (mode !== AppMode.TREE && activePhotoIndex !== i) child.lookAt(state.camera.position);
          });
        });

        return (
          <group ref={groupRef}>
            {photos.map((url, i) => (
              <Image key={i} url={url} transparent opacity={1} side={THREE.DoubleSide} />
            ))}
          </group>
        );
      };

      const Snow = () => {
        const count = 500;
        const mesh = useRef(null);
        const dummy = useMemo(() => new THREE.Object3D(), []);
        const particles = useMemo(() => {
          return Array.from({length: count}).map(() => ({
             t: Math.random() * 100,
             factor: 20 + Math.random() * 100,
             speed: 0.01 + Math.random() / 200,
             xFactor: -50 + Math.random() * 100,
             yFactor: -50 + Math.random() * 100,
             zFactor: -50 + Math.random() * 100,
             mx: 0, my: 0
          }));
        }, []);

        useFrame((state, delta) => {
          if(!mesh.current) return;
          particles.forEach((p, i) => {
             p.t += p.speed / 2;
             const a = Math.cos(p.t) + Math.sin(p.t) / 10;
             const b = Math.sin(p.t) + Math.cos(p.t * 2) / 10;
             const s = Math.cos(p.t);
             p.my -= p.speed * delta * 50;
             if(p.my < -20) p.my = 20;
             
             dummy.position.set(
               (p.mx / 10) * a + p.xFactor + Math.cos((p.t / 10) * p.factor) + (Math.sin(p.t) * p.factor) / 10,
               p.my + p.yFactor + Math.sin((p.t / 10) * p.factor) + (Math.cos(p.t * 2) * p.factor) / 10,
               (p.my / 10) * b + p.zFactor + Math.cos((p.t / 10) * p.factor) + (Math.sin(p.t * 3) * p.factor) / 10
             );
             dummy.scale.setScalar(s * 0.1 + 0.05);
             dummy.rotation.set(s*5, s*5, s*5);
             dummy.updateMatrix();
             mesh.current.setMatrixAt(i, dummy.matrix);
          });
          mesh.current.instanceMatrix.needsUpdate = true;
        });

        return (
           <instancedMesh ref={mesh} args={[undefined, undefined, count]}>
             <circleGeometry args={[0.1, 8]} />
             <meshBasicMaterial color="#ffffff" transparent opacity={0.6} depthWrite={false} />
           </instancedMesh>
        );
      };

      const CameraController = ({ gesture, mode }) => {
        const controlsRef = useRef(null);
        useFrame((state, delta) => {
          if (controlsRef.current && mode === AppMode.EXPLODED && gesture.type !== GestureType.IDLE) {
            const targetAzimuth = (gesture.position.x - 0.5) * Math.PI * 2;
            const targetPolar = gesture.position.y * Math.PI;
            controlsRef.current.setAzimuthalAngle(THREE.MathUtils.lerp(controlsRef.current.getAzimuthalAngle(), -targetAzimuth, delta * 2));
            controlsRef.current.setPolarAngle(THREE.MathUtils.lerp(controlsRef.current.getPolarAngle(), targetPolar, delta * 2));
            controlsRef.current.update();
          }
        });
        return (
          <OrbitControls 
            ref={controlsRef} 
            enableZoom={true} enablePan={false} 
            minPolarAngle={Math.PI/4} maxPolarAngle={Math.PI/1.5}
            autoRotate={mode === AppMode.TREE} autoRotateSpeed={0.5} 
          />
        );
      };

      const Scene = ({ mode, gesture, photos }) => {
         const [activePhoto, setActivePhoto] = useState(null);
         
         useEffect(() => {
           if(gesture.type === GestureType.PINCH && mode !== AppMode.TREE) {
              if(activePhoto === null) setActivePhoto(Math.floor(Math.random() * photos.length));
           } else if (gesture.type === GestureType.OPEN_HAND) {
              setActivePhoto(null);
           }
         }, [gesture.type, mode]);

         return (
           <Canvas shadows camera={{position: [0,0,18], fov: 45}} gl={{antialias: true, toneMapping: THREE.ACESFilmicToneMapping}}>
              <color attach="background" args={['#010a05']} />
              <ambientLight intensity={0.2} />
              <spotLight position={[10, 10, 10]} angle={0.15} penumbra={1} intensity={1} castShadow color="#ffd700" />
              <pointLight position={[-10, -10, -10]} intensity={0.5} color="#046307" />
              <Environment preset="city" />
              <group position={[0, -2, 0]}>
                 <Ornaments mode={mode} />
                 <PhotoCloud photos={photos} mode={activePhoto !== null ? AppMode.FOCUS : mode} activePhotoIndex={activePhoto} />
                 <Snow />
              </group>
              <Sparkles count={200} scale={12} size={2} speed={0.4} opacity={0.5} color="#C5A059" />
              <Stars radius={100} depth={50} count={5000} factor={4} saturation={0} fade speed={1} />
              <EffectComposer disableNormalPass>
                 <Bloom luminanceThreshold={0.5} mipmapBlur intensity={1.5} radius={0.4} />
                 <Vignette eskil={false} offset={0.1} darkness={1.1} />
              </EffectComposer>
              <CameraController gesture={gesture} mode={mode} />
           </Canvas>
         );
      };

      // --- APP COMPONENT ---
      
      const IconUpload = () => <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" y1="3" x2="12" y2="15"/></svg>;
      const IconCamera = () => <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M14.5 4h-5L7 7H4a2 2 0 0 0-2 2v9a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2V9a2 2 0 0 0-2-2h-3l-2.5-3z"/><circle cx="12" cy="13" r="3"/></svg>;
      const IconMouse = () => <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M3 3l7.07 16.97 2.51-7.39 7.39-2.51L3 3z"/><path d="M13 13l6 6"/></svg>;

      const App = () => {
        const [mode, setMode] = useState(AppMode.TREE);
        const [gesture, setGesture] = useState({ type: GestureType.IDLE, position: { x: 0.5, y: 0.5 } });
        const [photos, setPhotos] = useState([
          'https://picsum.photos/id/1011/400/400',
          'https://picsum.photos/id/1015/400/400',
          'https://picsum.photos/id/1016/400/400',
          'https://picsum.photos/id/1018/400/400'
        ]);
        const [permissionGranted, setPermissionGranted] = useState(false);
        const [showIntro, setShowIntro] = useState(true);

        useEffect(() => {
          const l = document.getElementById('loader');
          if (l) { l.style.opacity = '0'; setTimeout(() => l.style.display = 'none', 500); }
        }, []);

        const handleGestureUpdate = useCallback((newGesture) => {
          setGesture(newGesture);
          if (newGesture.type === GestureType.FIST) setMode(AppMode.TREE);
          else if (newGesture.type === GestureType.OPEN_HAND) setMode(prev => prev === AppMode.TREE ? AppMode.EXPLODED : prev);
        }, [mode]);

        const handleStart = async () => {
          try {
            await navigator.mediaDevices.getUserMedia({ video: true });
            setPermissionGranted(true);
            setShowIntro(false);
          } catch (e) { alert("Camera permission is required for gesture control."); }
        };

        const handleFileUpload = (e) => {
          if (e.target.files && e.target.files.length > 0) {
            const newPhotos = Array.from(e.target.files).map(file => URL.createObjectURL(file));
            setPhotos(prev => [...newPhotos, ...prev].slice(0, 15));
          }
        };

        return (
          <div className="relative w-full h-screen bg-black overflow-hidden font-sans text-christmas-silver">
            <div className="absolute inset-0 z-0">
               <Suspense fallback={null}><Scene mode={mode} gesture={gesture} photos={photos} /></Suspense>
            </div>
            
            <div className="absolute top-0 left-0 w-full p-6 flex justify-between items-start pointer-events-none z-10">
               <div>
                  <h1 className="text-4xl font-serif text-christmas-gold tracking-widest drop-shadow-[0_2px_10px_rgba(197,160,89,0.5)]">LUMIÈRE DE NOËL</h1>
                  <p className="text-xs tracking-[0.3em] uppercase opacity-70 mt-2">Interactive 3D Experience</p>
               </div>
               <div className="pointer-events-auto flex gap-4">
                  <label className="cursor-pointer bg-christmas-green/80 hover:bg-christmas-green border border-christmas-gold text-christmas-gold px-4 py-2 rounded-full flex items-center gap-2 transition-all backdrop-blur-sm">
                    <IconUpload /> <span className="text-sm font-bold">ADD PHOTOS</span>
                    <input type="file" multiple accept="image/*" className="hidden" onChange={handleFileUpload} />
                  </label>
               </div>
            </div>

            {permissionGranted && (
               <div className="absolute bottom-6 left-1/2 -translate-x-1/2 z-10 flex flex-col items-center pointer-events-none">
                  <div className="text-christmas-gold text-sm font-serif mb-2 tracking-widest uppercase">
                     Current Gesture: <span className="font-bold">{gesture.type}</span>
                  </div>
               </div>
            )}

            {!permissionGranted && !showIntro && (
              <div className="absolute bottom-10 left-1/2 -translate-x-1/2 z-20 flex gap-6">
                  <button onClick={() => setMode(AppMode.TREE)} className={`px-8 py-3 rounded-full border font-serif tracking-widest transition-all backdrop-blur-md ${mode === AppMode.TREE ? 'bg-christmas-gold text-black border-christmas-gold' : 'bg-black/40 text-christmas-gold border-christmas-gold/40'}`}>TREE MODE</button>
                  <button onClick={() => setMode(AppMode.EXPLODED)} className={`px-8 py-3 rounded-full border font-serif tracking-widest transition-all backdrop-blur-md ${mode === AppMode.EXPLODED ? 'bg-christmas-gold text-black border-christmas-gold' : 'bg-black/40 text-christmas-gold border-christmas-gold/40'}`}>EXPLODE MODE</button>
              </div>
            )}

            {showIntro && (
              <div className="absolute inset-0 z-50 flex items-center justify-center bg-black/90 backdrop-blur-md">
                 <div className="max-w-2xl w-full p-10 border border-christmas-gold/30 bg-christmas-green/20 rounded-xl text-center relative overflow-hidden shadow-[0_0_50px_rgba(0,0,0,0.8)]">
                    <div className="absolute top-0 left-0 w-full h-1 bg-gradient-to-r from-transparent via-christmas-gold to-transparent"></div>
                    <h2 className="text-5xl font-serif text-christmas-gold mb-8">Welcome</h2>
                    <p className="text-lg text-gray-300 mb-8 leading-relaxed">Experience a cinematic Christmas journey controlled by your hands.<br/>Use gestures to manipulate the magical tree and explore your memories.</p>
                    <div className="flex flex-col items-center gap-4">
                       <button onClick={handleStart} className="w-full max-w-sm bg-christmas-gold hover:bg-yellow-600 text-black font-bold py-4 px-10 rounded-full transition-all tracking-widest flex items-center justify-center gap-3"><IconCamera /> ENABLE CAMERA & ENTER</button>
                       <button onClick={() => { setPermissionGranted(false); setShowIntro(false); }} className="text-christmas-silver/50 hover:text-christmas-gold text-xs uppercase tracking-widest transition-all hover:scale-105 flex items-center gap-2 py-2"><IconMouse /> Continue without Camera</button>
                    </div>
                 </div>
              </div>
            )}

            {permissionGranted && <MediaPipeController onGestureUpdate={handleGestureUpdate} permissionGranted={permissionGranted} />}
          </div>
        );
      };

      const root = ReactDOM.createRoot(document.getElementById('root'));
      root.render(<App />);
    </script>
  </body>
</html>