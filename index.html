<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>Lumière de Noël</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Lato:wght@300;400&display=swap" rel="stylesheet">
    
    <!-- MediaPipe Hands -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    
    <!-- Babel -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <script>
      tailwind.config = {
        theme: {
          extend: {
            colors: {
              'christmas-green': '#023020',
              'christmas-gold': '#C5A059',
              'christmas-red': '#8A0303',
              'christmas-silver': '#E5E5E5',
            },
            fontFamily: {
              serif: ['Cinzel', 'serif'],
              sans: ['Lato', 'sans-serif'],
            },
          },
        },
      }
    </script>
    
    <style>
      body { margin: 0; padding: 0; overflow: hidden; background-color: #010a05; touch-action: none; }
      ::-webkit-scrollbar { display: none; }
      #root { width: 100vw; height: 100vh; }
      
      /* Initial HTML Loader to show while Babel compiles */
      #loader {
        position: fixed;
        inset: 0;
        background-color: #010a05;
        z-index: 9999;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        color: #C5A059;
        font-family: 'Cinzel', serif;
        transition: opacity 0.5s ease-out;
      }
      .spinner {
        width: 50px;
        height: 50px;
        border: 3px solid rgba(197, 160, 89, 0.3);
        border-radius: 50%;
        border-top-color: #C5A059;
        animation: spin 1s ease-in-out infinite;
        margin-bottom: 20px;
      }
      .error-msg {
        color: #8A0303;
        margin-top: 10px;
        font-size: 0.8rem;
        max-width: 80%;
        text-align: center;
      }
      @keyframes spin {
        to { transform: rotate(360deg); }
      }
    </style>
    
    <!-- STRICT Import Map: React 18 Only -->
    <script type="importmap">
{
  "imports": {
    "react": "https://esm.sh/react@18.2.0",
    "react/": "https://esm.sh/react@18.2.0/",
    "react-dom": "https://esm.sh/react-dom@18.2.0",
    "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
    "three": "https://esm.sh/three@0.160.0",
    "three/": "https://esm.sh/three@0.160.0/",
    "@react-three/fiber": "https://esm.sh/@react-three/fiber@8.15.16?external=react,react-dom,three",
    "@react-three/drei": "https://esm.sh/@react-three/drei@9.99.0?external=react,react-dom,three,@react-three/fiber",
    "@react-three/postprocessing": "https://esm.sh/@react-three/postprocessing@2.16.0?external=react,react-dom,three,@react-three/fiber",
    "lucide-react": "https://esm.sh/lucide-react@0.292.0?external=react",
    "react-dom/": "https://esm.sh/react-dom@^19.2.3/"
  }
}
</script>
    
    <!-- Global Error Handler -->
    <script>
      window.onerror = function(msg, url, line, col, error) {
        const loader = document.getElementById('loader');
        if (loader) {
          loader.innerHTML = `
            <div class="text-xl tracking-widest" style="color:#8A0303">ERROR</div>
            <div class="error-msg">${msg}</div>
            <div class="error-msg" style="font-family:monospace; margin-top:5px">Check console for details</div>
          `;
        }
        return false;
      };
    </script>
  </head>
  <body>
    <!-- HTML Loader -->
    <div id="loader">
      <div class="spinner"></div>
      <div class="text-xl tracking-widest">LOADING...</div>
    </div>

    <div id="root"></div>
    
    <!-- Application Logic -->
    <script type="text/babel" data-type="module" data-presets="react">
      import React, { useState, useEffect, useRef, useMemo, useCallback, Suspense } from 'react';
      import ReactDOM from 'react-dom/client';
      import * as THREE from 'three';
      import { Canvas, useFrame, useThree } from '@react-three/fiber';
      import { OrbitControls, Environment, Stars, Sparkles, Image, Loader } from '@react-three/drei';
      import { EffectComposer, Bloom, Vignette } from '@react-three/postprocessing';
      import { Upload, Camera, MousePointer2 } from 'lucide-react';

      /**
       * Constants
       */
      const AppMode = { TREE: 'TREE', EXPLODED: 'EXPLODED', FOCUS: 'FOCUS' };
      const GestureType = { IDLE: 'IDLE', FIST: 'FIST', OPEN_HAND: 'OPEN_HAND', PINCH: 'PINCH' };
      const COLORS = { EMERALD: '#023020', GOLD: '#C5A059', RED: '#8A0303', SILVER: '#E5E5E5' };
      const PARTICLE_COUNT = 300; 

      /**
       * Math Helpers
       */
      const generateTreePosition = (index, total, height = 15, radius = 6) => {
        const y = (index / total) * height - (height / 2);
        const normY = (y + height / 2) / height;
        const currentRadius = radius * (1 - normY);
        const angle = index * 137.5 * (Math.PI / 180);
        return [Math.cos(angle) * currentRadius, y, Math.sin(angle) * currentRadius];
      };

      const generateExplodedPosition = (radius = 15) => {
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(Math.random() * 2 - 1);
        const r = Math.cbrt(Math.random()) * radius;
        return [r * Math.sin(phi) * Math.cos(theta), r * Math.sin(phi) * Math.sin(theta), r * Math.cos(phi)];
      };

      /**
       * Gesture Service
       */
      const distance = (p1, p2) => Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
      const detectGesture = (landmarks) => {
        if (!landmarks || landmarks.length === 0) return GestureType.IDLE;
        const [wrist, , , , thumbTip, indexMCP, , , indexTip, middleMCP, , , middleTip, ringMCP, , , ringTip, pinkyMCP, , , pinkyTip] = landmarks;
        
        const isIndexOpen = distance(indexTip, wrist) > distance(indexMCP, wrist) * 1.2;
        const isMiddleOpen = distance(middleTip, wrist) > distance(middleMCP, wrist) * 1.2;
        const isRingOpen = distance(ringTip, wrist) > distance(ringMCP, wrist) * 1.2;
        const isPinkyOpen = distance(pinkyTip, wrist) > distance(pinkyMCP, wrist) * 1.2;
        const pinchDist = distance(thumbTip, indexTip);

        if (pinchDist < 0.05) return GestureType.PINCH;
        if (!isIndexOpen && !isMiddleOpen && !isRingOpen && !isPinkyOpen) return GestureType.FIST;
        if (isIndexOpen && isMiddleOpen && isRingOpen && isPinkyOpen) return GestureType.OPEN_HAND;
        return GestureType.IDLE;
      };

      /**
       * Components
       */
      const MediaPipeController = ({ onGestureUpdate, permissionGranted }) => {
        const videoRef = useRef(null);
        const handsRef = useRef(null);

        useEffect(() => {
          if (!permissionGranted || !videoRef.current || !window.Hands) return;
          
          const hands = new window.Hands({
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`,
          });

          hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5,
          });

          hands.onResults((results) => {
            if (results.multiHandLandmarks?.[0]) {
              const lm = results.multiHandLandmarks[0];
              onGestureUpdate({ type: detectGesture(lm), position: { x: lm[0].x, y: lm[0].y } });
            } else {
              onGestureUpdate({ type: GestureType.IDLE, position: { x: 0.5, y: 0.5 } });
            }
          });
          handsRef.current = hands;

          const startCamera = async () => {
             try {
               const stream = await navigator.mediaDevices.getUserMedia({ video: { width: 320, height: 240, facingMode: 'user' } });
               if (videoRef.current) {
                 videoRef.current.srcObject = stream;
                 await videoRef.current.play();
                 const send = async () => {
                   if (videoRef.current && handsRef.current) {
                     await handsRef.current.send({ image: videoRef.current });
                     requestAnimationFrame(send);
                   }
                 };
                 send();
               }
             } catch (e) { console.error(e); }
          };
          startCamera();

          return () => { hands.close(); };
        }, [permissionGranted]);

        return (
          <div className="fixed bottom-4 right-4 z-50 w-24 h-16 border border-christmas-gold rounded overflow-hidden bg-black opacity-50 hover:opacity-100 transition-opacity">
            <video ref={videoRef} className="w-full h-full object-cover -scale-x-100" playsInline muted />
          </div>
        );
      };

      const Ornaments = ({ mode }) => {
        const meshRef = useRef(null);
        const dummy = useMemo(() => new THREE.Object3D(), []);
        const color = useMemo(() => new THREE.Color(), []);
        
        const particles = useMemo(() => {
          const colors = [COLORS.GOLD, COLORS.RED, COLORS.SILVER, COLORS.EMERALD];
          return Array.from({ length: PARTICLE_COUNT }).map((_, i) => ({
            id: i,
            treePos: generateTreePosition(i, PARTICLE_COUNT),
            explodePos: generateExplodedPosition(12),
            color: colors[Math.floor(Math.random() * colors.length)],
            scale: Math.random() * 0.4 + 0.1
          }));
        }, []);

        useEffect(() => {
          if (meshRef.current) {
            particles.forEach((p, i) => {
              dummy.position.set(...p.treePos);
              dummy.scale.setScalar(p.scale);
              dummy.updateMatrix();
              meshRef.current.setMatrixAt(i, dummy.matrix);
              meshRef.current.setColorAt(i, color.set(p.color));
            });
            meshRef.current.instanceMatrix.needsUpdate = true;
          }
        }, [particles]);

        useFrame((state, delta) => {
          if (!meshRef.current) return;
          const step = 4 * delta;
          const time = state.clock.getElapsedTime();
          
          particles.forEach((p, i) => {
            let [tx, ty, tz] = p.treePos;
            if (mode === AppMode.EXPLODED || mode === AppMode.FOCUS) {
              const noise = Math.sin(time * 0.5 + p.id) * 0.5;
              tx = p.explodePos[0] + noise;
              ty = p.explodePos[1] + Math.cos(time * 0.3 + p.id) * 0.5;
              tz = p.explodePos[2];
            }
            
            meshRef.current.getMatrixAt(i, dummy.matrix);
            dummy.matrix.decompose(dummy.position, dummy.quaternion, dummy.scale);
            
            dummy.position.lerp(new THREE.Vector3(tx, ty, tz), step);
            dummy.rotation.x += delta * 0.5;
            dummy.rotation.y += delta * 0.5;
            dummy.updateMatrix();
            meshRef.current.setMatrixAt(i, dummy.matrix);
          });
          meshRef.current.instanceMatrix.needsUpdate = true;
        });

        return (
          <instancedMesh ref={meshRef} args={[undefined, undefined, PARTICLE_COUNT]} frustumCulled={false}>
            <icosahedronGeometry args={[1, 0]} />
            <meshStandardMaterial roughness={0.2} metalness={0.9} />
          </instancedMesh>
        );
      };

      const PhotoCloud = ({ photos, mode, activePhotoIndex, gesturePosition }) => {
        const groupRef = useRef(null);
        
        const photoPositions = useMemo(() => {
          return photos.map((_, i) => ({
            tree: generateTreePosition(i, photos.length, 12, 7),
            exploded: generateExplodedPosition(10),
            rotation: [0, Math.random() * Math.PI, 0],
          }));
        }, [photos]);

        useFrame((state, delta) => {
          if (!groupRef.current) return;
          const step = 3 * delta;
          groupRef.current.children.forEach((child, i) => {
            const posData = photoPositions[i];
            let targetPos = new THREE.Vector3(...posData.tree);
            let targetScale = 1.5;
            let targetRot = new THREE.Euler(...posData.rotation);

            if (mode === AppMode.EXPLODED) {
              targetPos.set(...posData.exploded);
              targetRot.set(0, 0, 0);
            }
            if (mode === AppMode.FOCUS && activePhotoIndex === i) {
              targetPos.set(0, 0, 3);
              targetScale = 4;
              targetRot.set(0, 0, 0);
            } else if (mode === AppMode.FOCUS && activePhotoIndex !== i) {
              targetPos.set(...posData.exploded);
              targetPos.multiplyScalar(2);
            }

            child.position.lerp(targetPos, step);
            child.scale.lerp(new THREE.Vector3(targetScale, targetScale, 1), step);
            child.rotation.x = THREE.MathUtils.lerp(child.rotation.x, targetRot.x, step);
            child.rotation.y = THREE.MathUtils.lerp(child.rotation.y, targetRot.y, step);
            child.rotation.z = THREE.MathUtils.lerp(child.rotation.z, targetRot.z, step);

            if (mode === AppMode.EXPLODED || (mode === AppMode.FOCUS && activePhotoIndex !== i)) {
               child.lookAt(state.camera.position);
            }
          });
        });

        return (
          <group ref={groupRef}>
            {photos.map((url, i) => (
              <Image key={i} url={url} transparent opacity={1} side={THREE.DoubleSide} />
            ))}
          </group>
        );
      };

      const Snow = () => {
        const count = 500;
        const mesh = useRef(null);
        const dummy = useMemo(() => new THREE.Object3D(), []);
        const particles = useMemo(() => {
          const temp = [];
          for (let i = 0; i < count; i++) {
            const t = Math.random() * 100;
            const factor = 20 + Math.random() * 100;
            const speed = 0.01 + Math.random() / 200;
            const xFactor = -50 + Math.random() * 100;
            const yFactor = -50 + Math.random() * 100;
            const zFactor = -50 + Math.random() * 100;
            temp.push({ t, factor, speed, xFactor, yFactor, zFactor, mx: 0, my: 0 });
          }
          return temp;
        }, [count]);

        useFrame((state, delta) => {
          if(!mesh.current) return;
          particles.forEach((particle, i) => {
            let { t, factor, speed, xFactor, yFactor, zFactor } = particle;
            t = particle.t += speed / 2;
            const a = Math.cos(t) + Math.sin(t * 1) / 10;
            const b = Math.sin(t) + Math.cos(t * 2) / 10;
            const s = Math.cos(t);
            particle.my -= speed * delta * 50; 
            if (particle.my < -20) particle.my = 20;

            dummy.position.set(
              (particle.mx / 10) * a + xFactor + Math.cos((t / 10) * factor) + (Math.sin(t * 1) * factor) / 10,
              particle.my + yFactor + Math.sin((t / 10) * factor) + (Math.cos(t * 2) * factor) / 10,
              (particle.my / 10) * b + zFactor + Math.cos((t / 10) * factor) + (Math.sin(t * 3) * factor) / 10
            );
            dummy.scale.setScalar(s * 0.1 + 0.05);
            dummy.rotation.set(s * 5, s * 5, s * 5);
            dummy.updateMatrix();
            mesh.current.setMatrixAt(i, dummy.matrix);
          });
          mesh.current.instanceMatrix.needsUpdate = true;
        });

        return (
          <instancedMesh ref={mesh} args={[undefined, undefined, count]}>
            <circleGeometry args={[0.1, 8]} />
            <meshBasicMaterial color="#ffffff" transparent opacity={0.6} depthWrite={false} />
          </instancedMesh>
        );
      };

      const CameraController = ({ gesture, mode }) => {
        const { camera } = useThree();
        const controlsRef = useRef(null);
        useFrame((state, delta) => {
          if (controlsRef.current) {
            if (mode === AppMode.EXPLODED && gesture.type !== GestureType.IDLE) {
              const targetAzimuth = (gesture.position.x - 0.5) * Math.PI * 2;
              const targetPolar = (gesture.position.y) * Math.PI;
              controlsRef.current.setAzimuthalAngle(
                THREE.MathUtils.lerp(controlsRef.current.getAzimuthalAngle(), -targetAzimuth, delta * 2)
              );
              controlsRef.current.setPolarAngle(
                 THREE.MathUtils.lerp(controlsRef.current.getPolarAngle(), targetPolar, delta * 2)
              );
            }
            controlsRef.current.update();
          }
        });
        return (
          <OrbitControls 
            ref={controlsRef}
            enableZoom={true} 
            enablePan={false}
            minPolarAngle={Math.PI / 4}
            maxPolarAngle={Math.PI / 1.5}
            autoRotate={mode === AppMode.TREE}
            autoRotateSpeed={0.5}
          />
        );
      };

      // App Component
      const App = () => {
        const [mode, setMode] = useState(AppMode.TREE);
        const [gesture, setGesture] = useState({ type: GestureType.IDLE, position: { x: 0.5, y: 0.5 } });
        const [permissionGranted, setPermissionGranted] = useState(false);
        const [showIntro, setShowIntro] = useState(true);
        const [photos, setPhotos] = useState([
          'https://picsum.photos/id/1011/400/400',
          'https://picsum.photos/id/1015/400/400',
          'https://picsum.photos/id/1016/400/400',
        ]);
        
        // Remove HTML loader when React App mounts
        useEffect(() => {
          const l = document.getElementById('loader');
          if(l) l.style.display = 'none';
        }, []);

        const handleStart = async () => {
            try {
                await navigator.mediaDevices.getUserMedia({ video: true });
                setPermissionGranted(true);
                setShowIntro(false);
            } catch { alert('Permission denied'); }
        };

        const handleFileUpload = (e) => {
          if (e.target.files && e.target.files.length > 0) {
            const newPhotos = Array.from(e.target.files).map(file => URL.createObjectURL(file));
            setPhotos(prev => [...newPhotos, ...prev].slice(0, 15));
          }
        };

        return (
          <div className="relative w-full h-full font-sans text-christmas-silver">
             <Canvas shadows camera={{ position: [0, 0, 18], fov: 45 }} gl={{ antialias: false, powerPreference: "high-performance" }}>
                <color attach="background" args={['#010a05']} />
                
                {/* Wrap Heavy Assets in Suspense to prevent blocking */}
                <Suspense fallback={null}>
                   <Environment preset="city" />
                   <group position={[0, -2, 0]}>
                     <Ornaments mode={mode} />
                     <PhotoCloud 
                        photos={photos} 
                        mode={mode} 
                        activePhotoIndex={null} 
                        gesturePosition={gesture.position} 
                     />
                     <Snow />
                     <Sparkles count={150} scale={10} size={4} speed={0.4} opacity={0.5} color="#C5A059" />
                   </group>
                </Suspense>

                <ambientLight intensity={0.5} />
                <pointLight position={[10, 10, 10]} intensity={1} color="#C5A059" />
                
                <EffectComposer disableNormalPass>
                  <Bloom luminanceThreshold={0.5} intensity={1.5} radius={0.4} />
                  <Vignette eskil={false} offset={0.1} darkness={1.1} />
                </EffectComposer>
                
                <CameraController gesture={gesture} mode={mode} />
             </Canvas>

             {/* UI Overlay */}
             <div className="absolute top-0 left-0 w-full p-6 pointer-events-none z-10">
                <h1 className="text-3xl font-serif text-christmas-gold drop-shadow-lg">LUMIÈRE DE NOËL</h1>
             </div>

             {/* Mode Controls */}
             {!permissionGranted && !showIntro && (
               <div className="absolute bottom-10 left-1/2 -translate-x-1/2 z-20 flex gap-4 pointer-events-auto">
                  <button onClick={() => setMode(AppMode.TREE)} className="px-6 py-2 bg-christmas-gold text-black rounded font-serif">TREE</button>
                  <button onClick={() => setMode(AppMode.EXPLODED)} className="px-6 py-2 border border-christmas-gold text-christmas-gold rounded font-serif bg-black/50">EXPLODE</button>
               </div>
             )}

             {/* Intro */}
             {showIntro && (
                <div className="absolute inset-0 z-50 flex items-center justify-center bg-black/90 backdrop-blur">
                  <div className="text-center p-8 border border-christmas-gold/30 rounded bg-christmas-green/20 pointer-events-auto">
                     <h2 className="text-4xl font-serif text-christmas-gold mb-6">Welcome</h2>
                     <button onClick={handleStart} className="bg-christmas-gold text-black px-8 py-3 rounded font-bold tracking-widest flex items-center gap-2 mx-auto">
                        <Camera size={20} /> ENABLE CAMERA
                     </button>
                     <button onClick={() => setShowIntro(false)} className="mt-4 text-xs text-gray-400 uppercase tracking-widest block mx-auto">Skip Camera</button>
                  </div>
                </div>
             )}

             {permissionGranted && (
               <MediaPipeController 
                  permissionGranted={permissionGranted} 
                  onGestureUpdate={(g) => {
                     if(g.type === GestureType.FIST) setMode(AppMode.TREE);
                     if(g.type === GestureType.OPEN_HAND) setMode(AppMode.EXPLODED);
                  }} 
               />
             )}
          </div>
        );
      };

      const root = ReactDOM.createRoot(document.getElementById('root'));
      root.render(<App />);
    </script>
  </body>
</html>